# LeetCode寻找两个有序数组的中位数（Hard）

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

---
题目本身不难，难在要求时间复杂度为log(m+n)。

## O(m+n)解法
首先考虑一个数组的情况，因为有序，中位数就是中间位置的数，长度为奇数直接返回，偶数时返回 `(arr[m-1] + arr[m]) / 2` ，时间复杂度O(1)

当两个数组时，很显然会想到把它合并成一个有序数组，用归并排序的归并操作，然后返回，时间复杂度O(m+n)。

更多O(m+n)解法可以看看这个题解

https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/

## 一种O(log(m+n))解法

我的思路是先将数组罗列在数轴上，将问题图形化，更好找思路。

例如：
```c
a0   a1  a2        a3   a4
        b0    b1         b2     b3   b5
-INF  ------------------------------  +INF
```
很显然，我们要找的就是一条线，这条线左边的元素个数等于右边的元素个数，这就是解题方向。

设 `m1 = a.length / 2; m2 = b.length / 2;`
则有 `m1 + m2 = (len1 + len2) / 2` 即 `m2 = (len1 + len2) / 2 - m1`。

观察数轴，很显然中位数就在m1和m2之间。

接着就可以选定一条数组做m1，根据m1算出m2，并根据边界条件每次对其折半查找。

具体的代码胜过千言万语：
```java
int m1 = (lo + hi) / 2;
int m2 = ((len1 + len2 + 1) / 2) - m1;
if (m1 != 0 && 
    m2 != len2 && 
    (nums1[m1 - 1] > nums2[m2])) { 
    //a左大于b右，往左减半
    hi = m1 - 1;
} else if (m1 != len1 && 
    m2 != 0 && 
    (nums1[m1] < nums2[m2 - 1])) { 
    //a右小于b左，往右减半
    lo = m1 + 1;
}
```

## 总结
思路对了以后，得到解法不难，但是折半和边界条件的处理很多细节很难。当然这种题最重要的还是训练自己的数学思路。